<?xml version='1.0'?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN" "http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd">
<article>

  <title>Prime Mover</title>

  <author><firstname>David</firstname><surname>Given</surname></author>

  <section>

    <title>Introduction</title>

    <section>

      <title>What is Prime Mover?</title>

      <para>Prime Mover (hereafter <command>pm</command>) is a build 
      tool, similar to <command>make</command>, but (hopefully) more 
      flexible and considerably more powerful.</para>

      <para>It is based on the Lua scripting language, so a knowledge 
      of Lua will most likely be useful if you want to write 
      pmfiles.</para>

      <para><command>pm</command> supports:</para>

      <itemizedlist>

        <listitem>

          <para>Automatic dependency checking for C-like files</para>

        </listitem>

        <listitem>

          <para>Explicit dependency graphs</para>

        </listitem>

        <listitem>

          <para>Arbitrarily complex rules (because you can embed chunks 
          of Lua, you can do anything you like without needing to spawn 
          an external process)</para>

        </listitem>

        <listitem>

          <para>Can handle multiple directories at the same time (no 
          more recursive makefiles!)</para>

        </listitem>

        <listitem>

          <para>Easy cross-compilation (object files are stored in 
          <command>pm</command>&apos;s own object file cache, not in 
          your build tree)</para>

        </listitem>

        <listitem>

          <para>Easy deployment (all of <command>pm</command>&apos;s 
          core code consists of exactly file, which can be run on any 
          platform --- no installation or compilation needed!)</para>

        </listitem>

        <listitem>

          <para>Object oriented design (making it very easy to create 
          your own rules by specialising one of the existing 
          ones)</para>

        </listitem>

      </itemizedlist>

      <para><command>pm</command> differs from make primarily in that 
      all dependencies in <command>pm</command> are explicit. <command>
      make</command> will attempt to determine what needs to be done to 
      build a file, based on a set of rules that tell it how to 
      transform file types. This works well until you need to have 
      <emphasis>different</emphasis> rules apply to two files of the 
      same type... which then causes <command>make</command> to quickly 
      become unmanageable.</para>

      <para><command>pm</command> avoids this by requiring all rules to 
      be explicit. This is much less work than it sounds, never 
      fear.</para>

      <para>The best explanation is an example, and so here is an 
      example pmfile that will build a simple C program:</para>

      <example>

        <title>A simple pmfile</title>

        <programlisting>-- load the C rules
include &quot;c.pm&quot;

-- default target builds a C program
default = cprogram {
  -- cfile transforms a C source file into an object file
  cfile &quot;main.c&quot;,
  cfile &quot;utils.c&quot;,
  cfile &quot;aux.c&quot;,

  -- once built, this makes the result available
  install = pm.install(&quot;myprogram&quot;)
}</programlisting>
      </example>

      <para>If this is saved as &apos;pmfile&apos; in the current 
      directory, it can be invoked by simply doing:</para>

      <screen>./pm</screen>
      <para>...and it will run.</para>

    </section>

    <section id="installation">

      <title>Installation</title>

      <para>Prime Mover needs no installation.</para>

      <para><command>pm</command> is deployed as a shell script that, 
      when executed, bootstraps itself into a binary executable. This 
      happens without the user&apos;s intervention; all it requires is 
      a C compiler that can be invoked with:</para>

      <screen>cc -o outputfile inputfile.c</screen>
      <para>Two versions of the shell script are provided. These are 
      functionally identical.</para>

      <itemizedlist>

        <listitem>

          <para><command>pm_8bit</command> is the recommended version; 
          it is a binary file (containing a gzipped data block).</para>

        </listitem>

        <listitem>

          <para><command>pm_7bit</command> is an alternative version 
          containing only text-friendly characters, and so can be 
          deployed in diff files. It is about 30% larger than <command>
          pm_8bit</command>.</para>

        </listitem>

      </itemizedlist>

      <para>It is intended that a copy of <command>pm</command> is 
      distributed with any project that uses it, so that it never needs 
      to be installed on the target system in order to be used. To 
      configure a project to use <command>pm</command>, all that needs 
      to be done is to drop a copy of whichever version you prefer into 
      your project&apos;s distribution directory --- I recommend the 
      project root, where your main pmfile will usually live.</para>

      <para>In addition, you may wish to include one or more of 
      <command>pm</command>&apos;s extension libraries. These supply 
      out-of-the box support for building various different kinds of 
      object. These can be found in the <filename>lib</filename> 
      directory in the <command>pm</command> distribution:</para>

      <itemizedlist>

        <listitem>

          <para><filename>lib/c.pm</filename> provides support for 
          building C executable and static libraries with gcc.</para>

        </listitem>

      </itemizedlist>

      <para>To summarise:</para>

      <itemizedlist>

        <listitem>

          <para>Copy <command>pm_8bit</command> or <command>
          pm_7bit</command> into your project directory. Call it 
          <filename>pm</filename>.</para>

        </listitem>

        <listitem>

          <para>Copy any, all or none of the extension libraries in lib 
          somewhere convenient (and not necessarily in the same place 
          as you put <command>pm</command> itself).</para>

        </listitem>

        <listitem>

          <para>Write your pmfile.</para>

        </listitem>

        <listitem>

          <para>You&apos;re done!</para>

        </listitem>

      </itemizedlist>

      <para>To execute <command>pm</command>, simply run it:</para>

      <screen>./pm</screen>
    </section>

  </section>

  <section>

    <title>Prime Mover from the user&apos;s perspective</title>

    <section>

      <title>Introduction</title>

      <para>So you&apos;ve just been presented with a package. It 
      contains some source, a copy of <command>pm</command>, and a 
      pmfile. What do you do with it?</para>

      <para>Well, ideally this should be spelt out for in the 
      package&apos;s README, but assuming that you&apos;re not the kind 
      of person who reads those, read on:</para>

      <para><command>pm</command> is designed to be familiar to people 
      who&apos;ve used <command>make</command>. If no extra setup or 
      options are needed, the minimum command needed to make everything 
      happen is:</para>

      <screen>./pm</screen>
      <para>This will invoke <command>pm</command> to try and run the 
      default rule, <varname>default</varname>, in the default file, 
      <filename>pmfile</filename>. Any intermediate files will be 
      placed in the intermediate file cache, which is by default in the 
      directory <filename>.pm-cache</filename>. The results of a build 
      process will be placed somewhere determined by the pmfile 
      itself.</para>

      <para>If a source file changes, then invoking <command>
      pm</command> again will cause only changed files (and any files 
      that depend on them) to be rebuilt. <command>pm</command> is 
      hopefully intelligent enough to always notice when a file needs 
      to be rebuilt, such as the modification of a source file or the 
      alteration of a compilation flag. In emergencies, or if you wish 
      to free up the disk space, the intermediate file cache can be 
      removed by hand or by using the <option>-p</option> option. 
      Unlike <command>make clean</command>, this is not intended to be 
      used between builds.</para>

    </section>

    <section>

      <title>Invocation</title>

      <para><command>pm</command> supports the following command line 
      options.</para>

      <itemizedlist>

        <listitem>

          <para><option>-h</option> or <option>--help</option> displays 
          a brief usage summary.</para>

        </listitem>

        <listitem>

          <para><option>--license</option> displays <command>
          pm</command>&apos;s redistribution license; see license for a 
          copy.</para>

        </listitem>

        <listitem>

          <para><option>-cX</option> or <option>--cachedir X</option> 
          sets pm&apos;s intermediate file cache directory to 
          <varname>X</varname>. By default, <varname>X</varname> is 
          <filename>.pm-cache</filename>. It&apos;s recommended that 
          this be on the same file system that any output files will be 
          on, as this prevents the need for copying of files, which can 
          be slow.</para>

        </listitem>

        <listitem>

          <para><option>-p</option> or <option>--purge</option> causes 
          <command>pm</command> to flush the intermediate file cache 
          before doing any build. The cache can, if desired, by removed 
          by hand if you don&apos;t want to use pm to do it. This can 
          be useful if you want to force pm to rebuild everything 
          (although normally you shouldn&apos;t have to).</para>

        </listitem>

        <listitem>

          <para><option>-n</option> or <option>--no-execute</option> 
          causes <command>pm</command> to go through the motions of 
          doing a build, but not to actually do anything. This can be 
          useful for testing a new pmfile.</para>

        </listitem>

        <listitem>

          <para><option>-fX</option> or <option>--file X</option> reads 
          in the pmfile <varname>X</varname>. This option may be 
          specified multiple times. If no pmfiles are explicitly 
          specified, then the file <filename>pmfile</filename> will be 
          automatically read in.</para>

        </listitem>

        <listitem>

          <para><option>-DX=Y</option> or <option>--define X=Y</option> 
          sets the variable <varname>X</varname> to the value 
          <varname>Y</varname>. May be specified multiple times. 
          <option>=Y</option> may be omitted, in which case the 
          variable is set to <constant>true</constant>.</para>

        </listitem>

      </itemizedlist>

      <para>Any number of rules may be specified on the command line; 
      the order is irrelevant. If no rules are specified, the rule 
      called <varname>default</varname> will be invoked.</para>

    </section>

    <section>

      <title>Rules</title>

      <para>A rule describes a collection of things that <command>
      pm</command> can build. Unlike <command>make</command>, all rules 
      must be declared explicitly; <command>pm</command> does not 
      automatically create rules depending on what is found in the file 
      system, and it is not possible to tell <command>pm</command> to 
      create, for example, only one file out of a set.</para>

      <para>It is normally up to the author of the pmfile to</para>

    </section>

    <section>

      <title>Common tasks</title>

      <para />

    </section>

  </section>

  <section>

    <title>Prime Mover from the developer&apos;s perspective</title>

    <section>

      <title>Introduction</title>

      <para>So you&apos;re a developer, and you&apos;ve got this 
      package you want to write a pmfile for. What do you do?</para>

      <para>The first thing to do is to install a copy of <command>
      pm</command> in the package as described in the 
      <xref linkend="installation"/> section. It is intended that pm 
      should be deployed with the package, to avoid the end user from 
      having to install <command>pm</command> (and the right 
      <emphasis>version</emphasis> of <command>pm</command>) in order 
      to build the package.</para>

      <para>The second thing to do is to pull out a text editor and 
      start writing the pmfile proper.</para>

    </section>

    <section>

      <title>Basic concepts</title>

      <para>A pmfile is a text file containing directives that tell 
      <command>pm</command> what to do.</para>

      <para>Technically, a pmfile is a Lua script (see 
      <xref linkend="lua"/>). When the pmfile is read, <command>
      pm</command> will execute the script, building a set of data 
      structures in memory. Once all scripts are read, <command>
      pm</command> will examine these data structures and use this 
      information to perform the build. This means that it is possible 
      to place any valid Lua code in a pmfile and have it execute; this 
      can be useful for autoconfiguration purposes, such as determining 
      what operating system is currently being used. However, for most 
      purposes this is all irrelevant. Most pmfiles will never use this 
      functionality.</para>

      <para>A pmfile is, fundamentally, made up of a nested tree of 
      clauses. Each clause is an instruction describing how to build 
      something. Each clause , and may in turn contain other clauses, 
      which describe its dependencies. Top level clauses are assigned a 
      name, and become rules.</para>

      <para>The syntax used is as follows:</para>

      <example>

        <title>Structure of a pmfile</title>

        <programlisting>rulename = clause {
  subclause { ... },
  subclause { ... },
  subclause { ... },
  ...etc...
}</programlisting>
      </example>

      <para>A clause may contain parameters as well as other 
      subclauses. These are specified as follows:</para>

      <example>

        <title>Clause parameters</title>

        <programlisting>rulename = clause {
  parametername = value,
  foo = 1,
  bar = 2,
  baz = &quot;This is a string&quot;,
  subclause { ... },
  ...etc...
}</programlisting>
      </example>

      <para>Parameters may have any name that is not a valid Lua 
      keyword --- see <xref linkend="lua"/> for more information --- 
      and any valid Lua type; usually, a number or a string.</para>

      <para>There are two types of parameter. If the name begins with a 
      lower-case letter, it is called an 
      <emphasis>attribute</emphasis>, and applies only to the clause it 
      was defined in. If the name begins with an upper-case letter, it 
      is called a <emphasis>variable</emphasis>, and applies to all 
      nested clauses as well. For example:</para>

      <example>

        <title>Attributes and variables</title>

        <programlisting>rulename = clause {
  attribute = 4,
  VARIABLE = 7,
  clause {
    -- This clause will see the value of VARIABLE, but
    -- not attribute.
  }
  -- This clause will see both VARIABLE and attribute.
}</programlisting>
      </example>

      <para>Attributes are used to configure the behaviour of an 
      individual clause --- for example, to tell it the filename to 
      build. Variables are used to configure the behaviour of an entire 
      tree --- for example, to tell it what compiler to use.</para>

      <para>Names of rules may be used interchangably with clauses. For 
      example:</para>

      <example>

        <title>Invoking named rules</title>

        <programlisting>program = clause {
  ... builds your application ...
}

documentation = clause {
  ... builds the documentation ...
}

default = group {
  program,
  documentation
}</programlisting>
      </example>

      <para>This is very useful for structuring your pmfiles such that 
      they can be read easily. (<function>
      <link linkend="group">group{}</link></function> is a standard 
      clause that invokes its children.)</para>

      <para>(Technically, rules defined in this way are a kind of 
      attribute. You may also define variables outside clauses, in 
      which case they apply to all clauses --- not just the ones after 
      the point at which they are defined.)</para>

      <para>Rules may be invoked any number of times this way. This is 
      particularly useful in conjunction with variables:</para>

      <example>

        <title>Using a variable to modify a rule</title>

        <programlisting>program = clause {
  ... builds your application, honouring the OPTIMISATION variable ...
}

program_with_optimisation = group {
  OPTIMISATION = &quot;on&quot;,
  program
}

program_without_optimisation = group {
  OPTIMISATION = &quot;off&quot;,
  program
}

default = group {
  program_with_optimisation,
  program_without_optimisation
}</programlisting>
      </example>

      <para>When the variable <varname>OPTIMISATION</varname> is set, 
      it applies to all children of the clause it is defined in --- 
      even if those children are defined elsewhere and merely referred 
      to.</para>

      <para>Rules may be nested in this way in an arbitrarily complex 
      fashion, although infinitely recursive structures are usually not 
      recommended (because they tend not to be useful).</para>

    </section>

    <section>

      <title>File and sugar</title>

      <para>There is one major exception to the rules described above 
      about how clauses work.</para>

      <para>Obviously, you can nest clauses as much as you like, and 
      define arbitrarily complex rules, but until you can actually do 
      something with them, the result will not be useful. As a result, 
      there is one special clause; <function><link linkend="file">
      file{}</link></function>. This clause is used to refer to a file 
      and is commonly used with a special syntax:</para>

      <example>

        <title>Using file{}</title>

        <programlisting>default = file &quot;filename&quot;</programlisting>
      </example>

      <para />

    </section>

  </section>

  <section>

    <title>Standard clauses</title>

  </section>

  <section>

    <title>Appendices</title>

    <section id="lua" xreflabel="The Emergency Guide to Lua">

      <title>The emergency guide to Lua</title>

      <para>Lua is a small but very subtle language, and a detailed 
      explanation is far beyond the scope of this document. If you are 
      interested, I strongly recommend reading the book <citation>
      <ulink url="http://www.lua.org/pil/">Programming in 
      Lua</ulink></citation>.</para>

      <para>This section does, however, attempt to summarise most of 
      Lua&apos;s basic features so that programmers who are used to 
      similar languages can get started in it quickly.</para>

    </section>

    <section>

      <title>The Prime Mover licence</title>

      <para>Prime Mover and all of its components, including this 
      document, are licenced under the MIT public licence. The full 
      text follows:</para>

      <blockquote>

        <para>Copyright (c) 2006 David Given</para>

        <para>Permission is hereby granted, free of charge, to any 
        person obtaining a copy of this software and associated 
        documentation files (the &quot;Software&quot;), to deal in the 
        Software without restriction, including without limitation the 
        rights to use, copy, modify, merge, publish, distribute, 
        sublicense, and/or sell copies of the Software, and to permit 
        persons to whom the Software is furnished to do so, subject to 
        the following conditions:</para>

        <para>The above copyright notice and this permission notice 
        shall be included in all copies or substantial portions of the 
        Software.</para>

        <para>THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT 
        WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT 
        LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A 
        PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE 
        AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES 
        OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR 
        OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE 
        SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</para>

      </blockquote>

    </section>

  </section>

</article>

